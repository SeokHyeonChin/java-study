# <strong>5. 클래스
### __GOAL__: 자바의 Class에 대해 학습하세요.
---

## <strong>5.1 객체란?
> '실제 세계는 사물(객체)로 이루어져 있으며, 발생하는 모든 사건들은 사물간의 상호작용이다.'

<br>

객체 지향 프로그래밍(영어: Object-Oriented Programming, OOP)은 컴퓨터 프로그래밍의 패러다임 중 하나이다. 객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 "객체"들의 모임으로 파악하고자 하는 것이다. 각각의 객체는 메시지를 주고받고, 데이터를 처리할 수 있다.

객체의 구성 요소
* 속성
  * so-called 멤버변수(variable)
* 기능
  * so-called 메서드(method)

객체 지향 프로그래밍의 주요특징
1. 코드의 재사용성이 높다.
2. 코드의 관리가 용이하다.
3. 신뢰성이 높은 프로그래밍을 가능하게 한다.
   
<br>

`객체(Object)`: 실제로 존재하는 것. 사물 또는 개념

`클래스(Class)`: 객체를 정의해 놓은 것(객체의 설계도 또는 틀) ex.붕어빵 틀

`인스턴스(Instance)`: 클래스로부터 만들어진 객체 ex. 붕어빵 틀로 찍어낸 슈크림 붕어빵

<br>

클래스는 전부 또는 일부를 그 클래스의 특성으로부터 상속받는 서브클래스를 가질 수 있으면, 클래스는 각 서브 클래스에 대해 수퍼 클래스가 된다. 서브클래스는 자신만의 메서드와 변수를 정의할 수도 있다.

이러한 클래스와 그 서브클래스 간의 구조를 "클래스 계층(class hierarchy)"이라 한다. (6차시 상속에서 계속)

<br><br><br>

## <strong>5.2 클래스 정의하는 방법

```java
public class Car{ // 클래스 이름: 파스칼 표기법 (ex. MyItems)
    // 필드
    int battery;        
    String engine;              // 인스턴스 변수

    static int hi = 500;        // 클래스 변수

    // 생성자
    Car() {}                            // 기본 생성자

    Car(int battery, String engine) {	// (사용자 정의)생성자
        this.battery = battery;
        this.engine = engine;
    }

    // 메서드
    void run() {...}
    void stop() {...}           // 인스턴스 메서드

    static int getHi() {...}    // 클래스 메서드
}
```

`필드(Field)`

* 객체의 고유 데이터, 객체의 현재 상태 데이터를 저장하는 곳이다.
* 생성자와 메서드 전체에서 사용되며 객체가 소멸되기 전까지 객체와 함께 존재한다.
  
`생성자(Constructor)`

* 인스턴스가 생성될 때 마다 호출되는 '인스턴스 초기화 메서드'

* 생성자는 메서드와 비슷하게 생겼지만 클래스 이름으로 되어있고 .

* 리턴 타입이 없다.

* 생성자를 실행시키지 않고 클래스로부터 객체를 만들 수 없다.

* 생성자가 생성되면 Heap Area에 객체가 생성되고 객체의 주소가 리턴된다.

* 리턴된 객체의주소는 클래스타입 변수에 저장되어 객체에 접근 할 때 이용된다.(클래스타입 변수는 메모리 stack 영역에 저장)

* 아무것도 안해도 디폴트 생성자가 만들어진다. (매개변수 X)
  * 단, 기본 생성자가 컴파일러에 의해 추가되는 경우는 클래스에 정의된 생성자가 하나도 없을 때 뿐이다.

* 오버로딩(Overloading) 가능
  * 한 클래스 내의 같은 이름을 가진 메서드이며, 매개변수의 개수 또는 타입이 다르다.(반환타입은 고려X)

`메서드(Method)`

* 객체의 동작에 해당한다.(절차 지향 프로그래밍에서의 함수)

* 메서드를 호출하게 되면 중괄호 블록에 있는 코드들이 일괄적으로 실행되고

* 필드 읽기, 수정, 객체간 협력 수단 등 다양한 기능을 수행하기 위해 사용되며

* 외부로부터 매개값을 받을 수 있고 실행 후 어떠한 값을 리턴 할 수도 있다.
  * 기본형 매개변수 - 값이 복사됨, read only
  * 참조형 매개변수 - 주소값이 복사됨, read & write
  * 반환 타입 역시 참조형이 될 수 있다. 아래 예시를 보면
  ```java
  class Data { int x; }

  class ReferenceReturnEx {
    public static void main(String[] args)
    {
      Data d = new Data();
      d.x = 10;

      Data d2 = copy(d);      // copy의 반환타입이 'Data'이므로 참조변수 d2를 'Data'타입으로 선언
      System.out.println(d.x); // 10
      System.out.println(d2.x); // 10
    }

    static Data copy(Data d) {
      Data tmp = new Data();  // 새로운 객체 tmp를 생성
      tmp.x = d.x;            // d.x의 값을 tmp.x에 복사

      return tmp;             // 객체 tmp의 주소를 반환
    }
  }
  """
  위와 같이 copy 메서드에서 return tmp를 하지 않는다면 copy 메서드 호출이 종료되면서 tmp 객체의 참조가 사라져서 사용할 수가 없다.

  반환타입이 참조형 = 메서드가 객체의 주소를 반환한다는 것을 의미
  """
  ```

* 메서드 이름은 자바 식별자 규칙에 맞게 작성한다.

* 숫자로 시작하면 안 되고, '$'와 '_'를 제외한 특수 문자를 사용하지 말아야 한다.

* 관례적으로 메서드 명은 소문자로 작성한다.

* 서로 다른 단어가 혼합된 이름이라면 뒤이어 오는 단어의 첫머리 글자는 대문자로 작성한다. (Camel 표기법)

* 메서드를 사용의 장점 - 높은 재사용성, 중복된 코드의 제거, 프로그램의 구조화

`인스턴스와 클래스의 차이`
* 인스턴스 변수 / 메서드
  * 인스턴스 생성 시 만들어짐
  * 인스턴스 메서드는 클래스 변수나 메서드를 사용할 수 있음
  * 인스턴스 변수는 JVM 메모리의 Heap영역에 저장됨
* 클래스 변수 / 메서드
  * 클래스 로딩 시 생성, 해당 클래스로 생성한 인스턴스들이 공유
  * 클래스 메서드는 인스턴스 변수나 메서드를 사용할 수 없음
    * 인스턴스변수는 인스턴스 생성이 이루어져야 존재하지만, 클래스메서드는 인스턴스 생성 없이도 호출 가능하므로 존재하지 않는 인스턴스변수가 호출될 수 있으므로 사용 금지됨
  * 인스턴스 변수를 사용하지 않는다면 클래스 메서드로 정의하는 것을 고려
    * 메서드 호출시간이 짧아져서 성능이 향상됨
  * 클래스 변수는 JVM 메모리의 메서드영역(static 영역)에 저장됨

`접근 제어자`

* `public`: 모든 패키지에서 해당 클래스로 접근가능
* `protected`: 상속받은 클래스에서 접근가능(동일 클래스 + 동일 패키지 + 자손 클래스)
* `(default)`: 자신을 포함한 패키지에서만 해당 클래스로 접근 가능(동일 클래스 + 동일 패키지)
* `private`: 자신을 포함한 클래스에서만 접근 가능

`그 외`
* `static` - 변수, 메서드는 객체가 아닌 클래스에 속한다.
* `final`
  * 클래스 앞에 붙으면 해당 클래스는 상속될 수 없다.
  * 변수 또는 메서드 앞에 붙으면 수정되거나 오버라이딩 될 수 없다.
* `abstract`
  * 클래스 앞에 붙으면 추상 클래스가 되어 객체 생성이 불가하고, 접근을 위해선 상속받아야 한다.
  * 변수 앞에 지정할 수 없다. 메서드 앞에 붙는 경우는 오직 추상 클래스 내에서의 메서드밖에 없으며 해당 메서드는 선언부만 존재하고 구현부는 상속한 클래스 내 메서드에 의해 구현되어야 한다.
* `transient` - 변수 또는 메서드가 포함된 객체를 직렬화할 때 해당 내용은 무시된다.
* `synchronized` - 메서드는 한 번에 하나의 쓰레드에 의해서만 접근 가능하다.
* `volatile` - 해당 변수의 조작에 CPU 캐시가 쓰이지 않고 항상 메인 메모리로부터 읽힌다.

<br><br><br>

## <strong>5.3 객체 만드는 방법 (new 키워드 이해하기)
```java
Car lambor = new Car(); // lambor라는 이름의 Car 객체(인스턴스)가 생성
```

1. new 연산자를 통해 JVM 메모리의 Heap 영역에 데이터를 저장할 공간을 할당하고, 참조값을 반환(이때, 생성자 Car()가 호출되어 수행됨)
2. 해당 참조값을 통해 객체에 접근이 가능
3. Stack 영역에 lambor라는 이름의 Car 참조변수를 위한 공간이 생성, 위의 참조값을 저장
4. 생성자 호출, 생성자를 통해 초기값을 설정

<br><br><br>

## <strong>5.4 메서드 정의하는 방법
```java
public class 클래스이름 {
  리턴타입 메서드이름 ([매개변수, ...]) {
    메서드 실행 블록
  }
}
```
<br><br><br>

## <strong>5.5 생성자 정의하는 방법
```java
클래스이름 ([매개변수선언, ...]){
  // 객체의 초기화 코드
}
```
생성자를 이용한 인스턴스의 복사
```java
class Car {
  String Color;
  String gearType;
  int door;

  Car() {
    this("white","auto",4);
  }
  
  Car(Car c) { // 인스턴스 복사를 위한 생성자
    color = c.color;
    gearType = c.gearType;
    door = c.door;
  }
}
```

<br><br><br>

## <strong>5.6 this 키워드 이해하기

```java
public void setX(int x) {
    this.x = x;
}

public void setY(int y) {
    this.y = y;
}
```
`this`키워드는 인스턴스 자신을 가르킨다. 위 코드에서 this를 사용함으로써 지역변수 x, y 구분할 수 있다. 당연한 말이지만 클래스 메서드에서는 this를 쓸 수 없다. 왜냐하면 인스턴스가 생성되지 않았을 수도 있기 때문이다.
```java
public class Point {
    int x;
    int y;
    int z;

    Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    Point(int x, int y, int z) {
        this(x, y);
        this.z = z;
    }
}
```
`this()`는 해당 클래스 생성자를 호출할 수 있다. 그렇기 때문에 생성자를 재사용하는 데 쓰인다. (생성자 체이닝)

<br><br><br>

## <strong>5.7 초기화 블럭(initialization block)
* 클래스 초기화 블럭
  * 클래스 변수의 복잡한 초기화에 사용
  * 클래스가 메모리에 처음 로딩될 때 한번만 수행
* 인스턴스 초기화 블럭
  * 인스턴스 변수의 복잡한 초기화에 사용
  * 생성자와 같이 인스턴스를 생성할 때 마다 생성자보다 먼저 수행

```java
class InitBlock {
  static { /*클래스 초기화 블럭*/ }

  { /*인스턴스 초기화 블럭*/ }
}
```

인스턴스 초기화 블럭의 경우 생성자의 오버로딩에서 중복을 없애줄 수 있다. (코드의 재사용성 향상)
```java
Car() {
  count ++;
  serialNo = count;
  color = "white";
}

Car(String color) {
  count++;
  serialNo = count;
  this.color = color
}

// 아래와 같이 중복을 없앨 수 있다

{
  count++;
  serialNo = count;
}

Car() {
  color = "white";
}

Car(String color) {
  this.color
```


>__멤버변수의 초기화 순서__ <br><br>
인스턴스변수: 기본값 -> 명시적초기화 -> 인스턴스 초기화 블럭 -> 생성자 <br>
클래스변수: 기본값 -> 명시적초기화 -> 클래스 초기화 블럭


<br><br><br>

## Reference

Book: Java의 정석 3rd Edition

https://kils-log-of-develop.tistory.com/406?category=923003

https://jeeneee.dev/java-live-study/week5-class/

https://velog.io/@jaden_94/5%EC%A3%BC%EC%B0%A8-%ED%95%AD%ED%95%B4%EC%9D%BC%EC%A7%80